\section{Introduction} 
\label{intro}

% natural code
Program synthesis is an active research direction~\cite{DBLP:journals/toplas/MannaW80, DBLP:journals/cacm/GulwaniHS12, 
DBLP:conf/icfp/Bodik15, DBLP:conf/pldi/KuncakMPS10, DBLP:conf/aplas/Solar-Lezama09, DBLP:conf/pldi/SrivastavaGCF11}.
The goal of program synthesis is to automatically derive code from a given specification.
The derived code is correct by construction and it should make the programmer more productive.
However, writing a complete specification of an entire program is often a more complex task than writing the corresponding code, even for very simple programs.

Programming by example~\cite{cypher93,lieberman01,synasc12} is a promising research direction that enables easy manipulation of data even for non-programmers~\cite{GulwaniHS12}. Recent work in this area has focused on manipulating fundamental data types such as strings~\cite{flashFillPOPL,vldb12,icml13}, lists~\cite{FeserCD15,Osera:2015} and numbers~\cite{cav12}. The success and impact of this line of work can be estimated from the fact that some of this technology ships as part of the popular FlashFill feature in Excel 2013~\cite{flashFillPOPL}.
 
Instead of writing code, the user provides a list of relevant examples and the synthesis tool automatically generates a program. 
In this way, the examples can be seen as an easily readable and understandable specification. 
In~\cite{Osera:2016}, the close connection between refinement types and examples is expounded through the lens of proof theory.
Other works have explored further ramifications of the theory of programming by example\cite{Osera:2015,gulwani,armando}.
These theoretical foundations give us the power and direction to begin to make programming by example a mainstream feature of fully featured languages.

In order for programming by example to be useful in the context of a real language, synthesis cannot act as a closed system.
Just as with code a user writes, the ability to reuse and edit synthesized code is an integral part of the programming process.
Program synthesis does not inherently address the problem of code readability, often resulting in tools that produce something closer to an executable than the simple and stylistic code a human might write.
Our goal is to synthesize code that can be naturally integrated into code written by a programmer.
In this paper we introduce an approach called \textit{natural synthesis} that reaches beyond the goal of synthesizing correct code, and synthesizes code from examples that is natural and idiomatic to the language.

Take the simple task of synthesizing a list flattening function from examples. 
Synthesis approaches that use only the primitive recursive operators~\cite{Osera:2015,FeserCD15}, would find a function similar to \codeinline{solution1} in Listing \ref{natSyn}.
Our tool instead focuses on actually utilizing these library functions (solution2).

\begin{lstlisting}[caption=Low-level synthesis vs. Natural synthesis,label=natSyn]
[[1,2],[3,4]] :-> [1,2,3,4]

solution1 xs = 
  (\c n -> foldr 
      (\x b -> foldr c b (id x))
      n xs) (:) []
      
solution2 xs =
  concatMap id xs
\end{lstlisting}

\noindent In fact, \codeinline{solution1} is an application of the GHC\cite{ghc} implementation of concatMap. To synthesize this solution using only the core higher order functions is certainly motivating, however a user would likely prefer to simply see \codeinline{concatMap} if using synthesis with the goal of writing their own code.

A natural synthesis system makes use of user defined functions and simulates program structures that commonly occur in the language.  
We choose to focus on functional programming, where a core part of the experience is writing higher order functions.  
Functional programming encourages specifying general behaviors in the form of abstract, higher-order functions, and then filling in details with first-order functions later.
Many users write higher order functions first, then combine them in interesting and useful ways.
Library authors often provide users with many higher order functions to allow users more easily write their applications.
Since users write higher order functions with a deep understanding of the domain, using them produces code that is more idiomatic and easier to understand then using generic higher order functions.

While using concatMap is certainly the most natural solution in Listing \ref{natSyn}, it is not surprising or novel solution. 
Since historically one of the exciting parts of program synthesis is to find unexpected results, this raises a question if it is possible for a natural synthesis system to create such results - after all, the stated goal is to find simple programs that a human might write.

In our results we have found many such cases in fact. 
For example, synthesizing the Boolean ``or'' function would return the expected \codeinline{any (id)}, where any is a built-in function to Haskell that returns \codeinline{True} if anything in a list satisfies the predicate function. 
Another solution that is unexpected is \codeinline{foldr1 (max)}, which exploits the \codeinline{Enum} property of the Boolean type in Haskell. 
Details of this will be discussed in Section \ref{evaluation}, but it enough to say here that this is evidence of the broad range of application for natural synthesis.

% fewer examples are needed when leveraging user functions
Although programming by example is an easy entry point for novice
users, one of the drawbacks can be the tedious nature of the
specification.  For a user, writing out a sufficient number of
examples for the synthesis tool to find a solution may involve
specifying seemingly obvious examples such as \codeinline{[]->[]} in
order to cover base cases of recursion.  However, much of this domain
specific knowledge is encoded by the user defined function, data types
and library imports.  By focusing our synthesis procedures on this
space of solution, we can reduce the number of edge case examples and
allow users to focus on the more natural examples.

In summary, our paper makes the following contributions:

\begin{enumerate}[topsep=0pt]
\item Adding natural synthesis into a real language (Haskell) to support a programming by example system that generates simple and reusable code.
\item Supporting user defined data types, first order functions, and higher order functions, as well as handling library imports to further support full integration into Haskell.
\item Automatically inferring refinement types on user defined higher order functions to assist with pruning the search space of synthesis. We use multiple passes of type match ranking algorithm to sort, prune, and when needed expand, the search space.
\item We present an evaluation of the performance of \ourTool/, as well as showing examples of the code that it can synthesize.
\end{enumerate}
