With the synthesis engine constructed, the system is ready to synthesize programs from examples.
Multiple programming-by-example queries can then be answered using this engine.
The synthesis engine only needs to be reconstructed when there are new library imports, or when there is a revision of the user-supplied code.

When examples are provided, the synthesis engine finds a suitable refinement type for a hypothetical function that could fit that example.
Then, \ourTool/ filters and ranks the higher order functions based on the refinement types known to the engine and the example types provided.
Once the candidate higher functions are identified, \ourTool/ will select and build first order functions that match the type of the higher order function's component signature to build a final set of candidate programs.

Each of these candidate programs is executed in best-first order against the set of inputs.
Whenever a function produces the correct outputs for each input, it is said to fit, and is reported to the user.
This search continues until the space is exhausted or it is manually interrupted. 
The search will always terminate since we are working over a finite space of generated functions, are our type reductions are strictly decreasing, which we will explain in Section \ref{typeMatch}

% getExampleType
% assignRType
\input{online1_assign}

\input{online2_rankByTypeMatch}

\input{online3_makeFxns}

