\section{Motivating Examples} 
\label{examples}


As an introduction to \ourTool/, imagine that a user wants to synthesis the simple \codeinline{stutter} function that will duplicate each element of a list.
The user will provide an example, and \ourTool/ will synthesis a program \codeinline{concatMap (replicate 2)} that fit that example.

\begin{lstlisting}
exs :: [[Int] :-> [Int]]
exs = [[1, 2, 3] :-> [1, 1, 2, 2, 3, 3]]
\end{lstlisting}

We might also imagine that the user was able to complete a piece of this program by writing a function \codeinline{dupl} to duplicate an element. Now \ourTool/ will provide the solution \codeinline{concatMap dupl}, as well as the solution above.

\begin{lstlisting}
dupl :: a -> [a]
dupl x = [x,x]
\end{lstlisting}

Because \ourTool/ only searches for natural and idiomatic programs that use higher order functions, very few examples are needed. In this case the user wants a function that will take numbers from a list as long as the numbers are odd. Only a single example is needed for \ourTool/ to unambiguously find the function \codeinline{takeWhile odd}. Another valid function might be \codeinline{head} to take the first element. Searching for first order functions is an active research direction, but in this work we instead focus only on higher order functions. A discussion of integrating our tool with first order searching techniques in provided in Section \ref{evaluation}.

\begin{lstlisting}
exs :: [[Int] :-> [Int]]
exs = [[1, 2, 3] :-> [1]]
\end{lstlisting}

Working on user defined datatypes is also a commonplace task \ourTool/ supports. In the next example the user has provided a binary tree data structure and a function to map over it. For the sack of brevity, we show the synthesis the exceedingly simple program \codeinline{mapBTree not}.

\begin{lstlisting}
data BTree a = Nil |
               Branch (BTree a) a (BTree a)

mapBTree :: (a -> a) -> BTree a -> BTree 
mapBTree f Nil = Nil
mapBTree f (Branch b1 v b2) = 
  Branch (mapBTree f b1) (f v) (mapBTree f b2)

exs :: [BTree Bool :-> BTree Bool]
exs = [Branch Nil True Nil :->
       Branch Nil False Nil]
\end{lstlisting}

It may seem that if a user can write a higher order functions over custom data structures, they would not have a need to synthesize such functions.
However, imagine the incredibly common case of a user importing libraries.
Haskell's module system and large repository of libraries like Hackage and Stackage are an indispensable part of the language\cite{hackage,stackage}.
Often, a user is importing a library that is large, unfamiliar, and/or poorly documented.
Using \ourTool/, the user no longer needs an intimate knowledge of the library to makes use of the functions and datatypes, and can instead synthesize functions from examples.

As an example, we show code to transpose a music value from the Euterpea DSL for music\cite{Euterpea}.
Among other things, Euterpea defines a tree-like datatype called \codeinline{Music} and various functions for manipulating these types.
The user only needs to express the basic datatype as examples, and \ourTool/ can synthesize the \codeinline{solution} program.
The solution utilizes the functions from Euterpea; \codeinline{mMap} for mapping over music values, and \codeinline{(trans::Int->Music Pitch->Music Pitch)} to transpose a Music Pitch by a value.
Because we have synthesized a natural looking program, the user does not need to understand details of the library's function and data structures to be able to immediately gain an intuition about how the solution program works.

\begin{lstlisting}
import Euterpea

exs :: [Music Pitch :-> Music Pitch]
exs = [
  (Prim (Note qn (C,4)):+:Prim (Note qn (D,4)) :->
  (Prim (Note qn (D,4)):+:Prim (Note qn (E,4)) ]
        
solution = mMap (trans 2)
\end{lstlisting}

\markk{should we list the solution program that lambda squared would give? It would be long and full of cases and folds and maps}
