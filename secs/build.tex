
\subsection{Refinement type inference}
We first compile \textbf{map2} and \textbf{mapR} into the synthesis engine, which will later be used to find an implementation of \textbf{exs}.
Compiling the higher order functions into the synthesis engine is the equivalent of generating hypotheses about the higher order function in $\Lambda^2$.
We separate these hypotheses into two classes - \textit{search space reducers} and \textit{subexample generators}.
The search space reducers take the form of refinement types, while the subexample generators are functions.

Refinement types are chosen by generating and applying many examples with QuickCheck for each higher order function, as in \textbf{filterExs}.
We type check these examples against a pool of common and simple refinement types to chose a useful and correct refinement type for the higher order function.

\begin{minted}{haskell}
testInputs = [( (>20), [10,20,30]
              , even, [6,7,8]
              , True, ['a','b','c'])]
filterExs = map filter testInputs
filter  :: (a -> Bool)
        -> xs:[a]
        -> {ys:[a] | len xs >= len ys}
map2    :: (a -> b)
        -> xs:[a]
        -> {ys:[a] | len xs < len ys}
\end{minted}

The subexample generation functions are synthesized from examples collected by wrapping the component function in a state monad to collect a record of its executions.
We now have a set of examples for top-level input, top-level output, and subexample.
We can recursively call PBE... This isn't the right way I think.


\begin{minted}{haskell}
p' p x = write x >> write (p x) >> return (p x)
filterSubs = map (filter p') testInputs
{- ([10,20,30] ~> [30] ~> [10 ~> False, 20 ~> False, 30 ~> True]
   ,[6,7,8] ~> [6,8] ~> [6 ~> True, 7 ~> False, 8 ~> True]
   ,['a','b'] ~> ['a','b'] ~> ['a' ~> True, 'b' ~> True] -}
   
filterGen :: [[a] ~> [a]] -> [(a ~> Bool)]
filterGen = synthesize filterSubs
mapGen :: [[a] ~> [b]] -> [(a ~> b)]
\end{minted}
