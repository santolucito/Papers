\subsection{Type match ranking}


%filter on RType and rank

Once these higher order functions have been culled from the pool of candidates, we update their ranks that had been assigned based on their code locality.
The closer the example type is to the candidate higher order function, the more that function will advance in the ranking.
In Listing \ref{costAlgo}, we present a demonstration of part of this ranking algorithm.

\begin{lstlisting}[caption=Type closeness ranking algorithm,label=costAlgo]
cost :: Type -> Type -> Int
cost (TyParen t1) (TyParen t2) =
  1 + cost t1 t2
cost (TyFun t1 t1') (TyFun t2 t2') =
   1 + (cost t1 t2) + (cost t1' t2')
cost (TyCon q1) (TyCon q2) =
   if (q1==q2) then 20 else 0
cost _ _ = 0
\end{lstlisting}

Using these updated rankings, we iterate through each in best-first order. For each higher-order function, we supply it with arguments until it is compatible with the type signature implied by the example set. In accordance with our problem definition in Section \ref{problem}, we can assume the final argument of the function is the input. Any other initial value types are satisfied by selecting from a pool of default values, and function types are satisfied by searching for first-order functions that would make the resulting signatures match. If it is not possible to find values that fit, the search moves on to the next higher-order function.

To choose the component function we weighted subtyping algorithm.
When two types have weight of >1, we will say type a \textit{generalizes} type b.
\markk{someone probably wrote something about this, just need to find out where and cite.}
If we have the higher order function map :: (a->b) -> [a] -> [b] and the examples :: [Int] -> [Int], then our component function f might have f::a->b, or f::Int->Int, or f::Int->a, but certainly not f::[Bool]->[Bool].

We identify two separate classes of higher order functions - those that take a single first order function, and those that need initial values in addition to a function. The \codeinline{map} function only takes a first order function, while \codeinline{foldl :: (a-> b-> a)-> a-> [b]-> a} requires an initial value for \codeinline{a}. While the process described so far handles the former, initial values must also be addressed.

To identify initial values in a type signature, we can use our previous assumption that all higher order function have been partially curried to the type \codeinline{_ -> *-> *}. Adding the further assumption that only one first order function maybe be passed to the higher order function, we simply tag any non-function type in the hole as an initial value.

\markk{we could expand types (Int) -> (Int -> Int) but would create an possibly infinite recursion.}