\subsubsection{Refinement Type Generation}

% collectTypesAndWeights
The first step of our algorithm is line 7 of Listing \ref{listing:Algo}. We first collect all of the type signatures from our sources (user code, imports, and standard library). In order to rank the higher-order functions, we assign weights based on their source location. User-defined functions are given the highest priority, while direct imports are given less, and the standard libraries are given the least. These rankings will contribute to the final ranking of candidate functions in the synthesis stage when we match the component function signatures on the examples.

% filter isHigherOrder
We filter through these to select only the higher order functions. Because in Haskell the function type constructor ($\to$) is right binding, any higher order functions must have parenthesis in the type signature, which provides a convenient, though over approximating, filtering predicate.

% assignRTypes
Listing \ref{listing:addRType} expands on line 9 of Listing \ref{listing:Algo} to show how we automatically generate refinement types for our higher order functions.
These refinement will be used to prune the search space in synthesis, as explained in detail in section \ref{synth}.
In brief, the size relation that applies to the higher order functions must also apply to the examples in order to consider that function as a candidate.
Our \texttt{allPossibleRTypes} predicates specify size constraints on input and output of $\leq,\geq,=$.

\begin{lstlisting}[caption=Adding refinement types to higher order functions,label=listing:addRType]
assignRTypes ::Sig -> IO(Sig, [RType])
assignRTypes sig = do
   x <- if eqTypes (lastTyps sig) 
       then rTypeAssign sig
       else return [noRType]
   return (t, x)

testRs :: Sig -> IO([RType])
testRs s =
  filterM (runLiquidHaskell s) allPossibleRTypes
\end{lstlisting}

%> map rTypeTemplate ["=","<=",">="]
For every predicate we test against, we are able to more accurately prune the search space of higher-order functions.
However, since we must test every higher-order function in scope on these predicates, the cost to add a predicate is high.
Although this offline, engine building stage only needs to be run once on a given a set of code and imports, liquidHaskell type checking is still fairly expensive (in part because it is applied using IO).
Therefore, it is best to only select as many refinement types as are needed.

\begin{lstlisting}[caption=A satisfying refinement type for map]
map :: _ $\to$ i:[a] $\to$ {o:[b] | (len i) = (len o)}
\end{lstlisting}

Notice that in line 3 of Listing \ref{listing:addRType}, we specify that we should only generate refinement types in the case that the input and output types of the higher order functions are the same (up to equality on the top level type constructor).
In the case that the input and output type are different, the size measures between two different type constructors are not guaranteed to have any significance.
A relation on these values may be useful on occasion, but in practice is more often only a confounding factor, leading to wasted computation.
Since LiquidHaskell is the largest cost to our system, removing refinement type inference in these ambiguous cases provides a large performance gain.
As an example of the performance gain, in processing the Haskell standard library, base:Prelude, there are 7 out of 30 cases of higher order functions that do not need to be checked against refinement types using this approach.
When we do not assign refinement types to a higher order function, we instead prune our search space in the synthesis stage by utilizing a subtype ranking system to be explained in more detail in section \ref{synth}.


\subsubsection{User defined data types}
%We focus only higher order functions that manipulate data structures
In order to support user defined data structures, we only require that a user implements some kind of measure\cite{realWorldLiquid} over their data structure.
This size function will help the system determine size constraints on the examples, so that we can pick higher order functions that might actually work.
In fact, a size function could just be a constant function, which means the system will test every higher-order function that fits the types. 
\markk{Maybe this should even be a builtin default? If liquid haskell says no def for len, just set the type to true - thats an easy hack}

As an example, take the code from section \ref{examples} for synthesizing a music function.
the user would have needed to provide a measure function for Music a.
This measure will allow liquidHaskell to draw conclusions about the size of examples of type [Music a :-> Music a], as well as conclusions about higher order functions over the Music data structure.

\begin{lstlisting}
import Euterpea

{-@ measure len @-}
len :: Music a -> Int
len m =
  case m of
    Prim _     -> 1
    m1 :+: m2  -> len m1 + len m2
    m1 :=: m2  -> len m1 + len m2
    Modify c m -> len m
\end{lstlisting}



