\subsubsection{Refinement Type Generation}

%>  filter ishigherOrder tys
We first collect all of the type signatures from our sources (user code, imports, and standard library). We filter through these to select only the higher order functions. Because in Haskell the function type constructor ($\to$) is right binding, any higher order functions must have parenthesis in the type signature, which provides a convenient, though over approximating, filtering predicate.

%> let uHOTyps = f 3000 typSigs
%> let iHOTyps = f 2000 importSigs
%> let pHOTyps = f 1000 preludeTypSigs
In order to rank the higher-order functions, we assign weights based on their source location. User-defined functions are given the highest priority, while direct imports are given less, and the standard libraries are given the least. These rankings will contribute to the final ranking of candidate functions in the synthesis stage when we match the component function signatures on the examples.

%> hoRTyps <- mapM (addRType fc) (map fst allHOTyps)
%> HigherOrderFxn -> (injectRFxnType fxn .fst)
We automatically generate refinement types for our higher order functions that will be used to prune the search space in synthesis.
In the case that the input and output types of the higher order functions are the same (up to the top level type constructor), we generate a LiquidHaskell predicate that relates the size of those types.
the size relation that applies to the higher order functions must also apply to the examples in order to consider that function as a candidate.   

%> map rTypeTemplate ["=","<=",">="]
When the input and output types are the same, or use the same top level type constructor, we generate hypotheses as liquidHaskell predicates.
Our predicates specify size constraints on input and output of $\leq,\geq,=$.
For every predicate provided, we are able to more accurately prune the search space of higher-order functions, but we must test every higher-order function in scope on these predicates. 
Therefore, it is best to only select as many refinement types as is needed.
Although this offline stage only needs to be run once given a set of code and imports, liquidHaskell type checking is still fairly expensive.

In the case that the input and output type are different, we note that the size measures between two different type constructors are not guaranteed to have any significance.
A relation on these values may be useful on occasion, but in practice is more often only a confounding factor.
Since LiquidHaskell is the largest cost to our system, removing refinement type inference in these ambiguous cases provides a large performance gain.
As an example of the performance gain, in processing the Haskell standard library, base:Prelude, there are \markk{X} cases of refinement type checking we can skip.
Without refinement types, we utilize a subtype ranking system in the synthesis stage to prune and order our search space.


\subsubsection{User defined data types}
%We focus only higher order functions that manipulate data structures
In order to support user defined data structures, we only require that a user implements some kind of measure\cite{realWorldLiquid} over their data structure.
This size function will help the system determine size constraints on the examples, so that we can pick higher order functions that might actually work.
In fact, a size function could just be a constant function, which means the system will test every higher-order function that fits the types. 
\markk{Maybe this should even be a builtin default? If liquid haskell says no def for len, just set the type to true - thats an easy hack}

As an example, take the code from section \ref{examples} for synthesizing a music function.
the user would have needed to provide a measure function for Music a.
This measure will allow liquidHaskell to draw conclusions about the size of examples of type [Music a :$\to$ Music a], as well as conclusions about higher order functions over the Music data structure.

\begin{lstlisting}
import Euterpea

{-@ measure len @-}
len :: Music a -> Int
len m =
  case m of
    Prim _  -> 1
    m1 :+: m2 -> len m1 + len m2
    m1 :=: m2 -> len m1 + len m2
    Modify c m -> len m
\end{lstlisting}



