\subsection{Refinement type inference}

%>  filter ishigherOrder tys
We first collect all of the type signatures from our sources (user code, imports, and standard library). We filter through these to select only the higher order functions. Because in Haskell the function type constructor (->) is right binding, any higher order functions must have parenthesis in the type signature, which provides a convenient filtering predicate.

%> let uHOTyps = f 3000 typSigs
%> let iHOTyps = f 2000 importSigs
%> let pHOTyps = f 1000 preludeTypSigs
In order to rank the higher-order functions we assign weights based on their source location. User-defined functions are given the highest priority, while direct imports are given less, and the standard libraries are given the least. These rankings will contribute to the final ranking of candidate functions in the synthesis stage when we match the component function signatures on the examples.


%> hoRTyps <- mapM (addRType fc) (map fst allHOTyps)
%> HigherOrderFxn -> (injectRFxnType fxn .fst)
We automatically generate search space pruning hypotheses for our higher order functions.
In the case that the input and output types of the higher order functions are the same, we generate a LiquidHaskell predicate that relates the size of those types.
In this case, the hypothesis that applies to the higher order functions must also apply to the examples in order to consider that function as a candidate.
In the case that the input and output type are different, we defer the analysis to the synthesis stage and use our ranking system to good effect.

In order to derive these hypotheses, we require all higher order functions be be of a unified Kind (?) \texttt{$\_ \to * \to *$}, where the penultimate kind of the signature is the input and the final kind is the the output. functionally, this means we require that the user partially uncurry any higher order function they are interested in using during synthesis.

This is a simple procedure, but requires user knowledge of which parameters to the function will be given by the examples. 
As an example consider \texttt{zipWith' f (xs,ys) = zipWith f xs ys}, which will yield the type \texttt{zipWith' :: (a$\to$ b $\to$ c) $\to$ ([a],[b]) $\to$ [c]}. 
%The liquidHaskell predicate applied to this signature will be of the effect of \texttt{len([a],[b]) = len([c])}.


%> map rTypeTemplate ["=","<=",">="]
When the input and output types are the same, or use the same top level type constructor, we generate hypotheses as liquidHaskell predicates.
Our predicates specify size constraints on input and output of $\leq,\geq,=$.
For every predicate provided, we are able to more accurately prune the search space of higher-order functions, but we must test every higher-order function in scope on these predicates. 
Therefor, it is best to only select as many refinement types as is needed.
Although this offline stage only needs to be run once given a set of code and imports, liquidHaskell type checking is still fairly expensive.



\subsection{User defined data types}
%We focus only higher order functions that manipulate data structures
In order to support user defined data structures, we only require that a user implements some kind of measure\cite{realWorldLiquid} over their data structure.
This size function will help the system determine size constraints on the examples, so that we can pick higher order functions that might actually work.
In fact, a size function could just be a constant function, which means the system will test every higher-order function that fits the types. 
Maybe this should even be a builtin default?

As an example, take the code from section \ref{examples} for synthesizing a music function.
the user would have needed to provide a measure function for Music a.
This measure will allow liquidHaskell to draw conclusions about the size of examples of type [Music a :$\to$ Music a], as well as conclusions about higher order functions over the Music data structure.

\begin{minted}[fontsize=\footnotesize]{haskell}
import Euterpea

{-@ measure len @-}
len :: Music a -> Int
len m =
  case m of
    Prim _  -> 1
    m1 :+: m2 -> len m1 + len m2
    m1 :=: m2 -> len m1 + len m2
    Modify c m -> len m
\end{minted}


\subsection{Extending Liquid Haskell
}%this hasn't happened yet (and probably wont for this paper)
LiquidHaskell does not support certain popular syntax extensions to Haskell, such as LambdaCase (TODO list others). In the spirit of this work, we wish to support as much user defined code as possible. To this end, we can extend the refinement type system by allowing refinement type inference on repersentative examples of a higher order function. Take the following code (pick something from an actual library on hackage.

\begin{minted}[fontsize=\footnotesize]{haskell}
{-# LANGAUGE LambdaCase #-}

fooMap :: (a -> b) -> [a] -> [b]
fooMap f = \case
  [] -> []
  l -> map f l
 \end{minted}


We generate and applying many examples with QuickCheck for each higher order function.
We then apply a similar refinement type inference strategy as above to these examples.
This lets us support a larger subset of the language, and, in theory refinement type inference for other languages too!

There are however repercussions to this approach. We are not guaranteed to generate a correct refinement type because we might not generate a fully representative examples. So
\end{comment}