\subsection{Limitations}

Without subexample generation we cannot recursively apply our algorithm to create programs with multiple applications of higher order functions as in the   $\Lambda^2$ paper\cite{isil}. Since they provide hard coded subexample generation hypotheses for the higher order functions they use, this does not scale.

With the eventual goal of building a complete program synthesis engine, we will need to integrate the first order function synthesis. While this problem has been investigated in isolation, it is not clear how to efficiently determine if  a set of examples will require a higher order function or a first order function.

The user must provide a concrete type signature for the examples. This could be fixed by making use of Haskell's monomorphism restriction and inline the inferred concrete type signature.

\subsection{Optimizations}

\subsection{Related}
Subexample generation from that other paper\cite{isil} is one example of a (powerful) dismantling procedure.
Subexample generation also gives the ability to recursively call the synthesis engine to generate programs with multiple applications of a high order function.
Because subexample generation is hard, and we dont know how to do it yet, we present a different idea.
Our dismantling procedure will deduce a specialized component signature given a higher order signature and the examples signature.