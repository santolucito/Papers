A core part of the functional programming experience is writing higher order functions. The functional programming approach encourages specifying general behaviors in the form of abstract, higher-order functions first, and filling in details with first-order functions later.

A core part of the functional programming experience is writing higher order functions. Many users write higher order functions first, then combine them in interesting and useful ways. Library authors often provide users with many higher order functions to allow users more easily write their applications. With this in mind, we provide a synthesis engine that is able to leverage user defined higher order functions.

Since users write higher order functions with a deep understanding of the domain, using them will produce code that is more idiomatic and easier to understand then using generic higher order functions. Additionally, fewer examples are needed because we have access to the domain specific knowledge encoded by the user library.

\begin{lstlisting}
--User has their own library of fxns
f = replicate 2

--and wants to synthesize stutter
exs :: [[Int] :-> [Int]]
exs = [[1, 2, 3] :-> [1, 1, 2, 2, 3, 3]]

-- We find the program = concatMap f
-- with extended search turned on
-- we can also find program = concatMap (replicate 2) 
\end{lstlisting}

The user can also use this tool to synthesize new, simpler versions of a program. 

\begin{lstlisting}
--a simpler, more natural stutter program
exs :: [[Int] :-> [Int]]
exs = [[1, 2, 3] :->
       foldl (\xs x -> xs++[x,x]) [1,2,3]]

-- We find the program = concatMap f
-- with extended search turned on
-- we can also find program = concatMap (replicate 2) 
\end{lstlisting}


If a user is importing a library, they can also synthesize programs that use those function. As an example, we show code to transpose a music value from the Euterpea DSL for music in haskell.

\begin{lstlisting}
import Euterpea

third :: Pitch -> Pitch
third = trans 3

exs :: [Music Pitch :-> Music Pitch]
exs = [ (c 4 qn  :+: d 4 qn) :->
        (ef 4 qn :+: f 4 qn) ]
        
-- will use mMap (musicMap) and third
prog = mMap third
\end{lstlisting}
